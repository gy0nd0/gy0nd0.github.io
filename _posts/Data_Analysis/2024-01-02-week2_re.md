# -*- coding: utf-8 -*-
"""week2_re.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10DlmGCy0OFZUd-p0oJ8NXn9zeQ2aJ9xe

# 데이터 분석에 활용되는 다양한 기초 문법
- 주로 pandas에서 제공되는 함수를 이용한다.
- 분석과 더불어 전처리에도 다양한 함수들이 사용된다.
- 데이터 분석은 이론과 더불어 다양한 함수들을 직접 적용해서
데이터를 가공하는 과정을 직접 경험해보는 것이 중요하다.
"""

import pandas as pd #먼저 pandas를 import 해준다.

df = pd.read_csv('exam.csv') #다양한 함수를 적용해볼 수 있는 데이터를 불러온다.

df.head() #주어진 데이터는 id, nclass, math, english, science의 정보를 가지고 있다.

"""## query('조건')
- 조건에 맞는 데이터를 추출하는 경우에 사용된다.
"""

df.query('nclass == 3')
#query는 괄호 내부 따옴표 안에 들어간 조건을 만족하는 데이터를 행별로 불러온다.
#예시에는 nclass가 3인 데이터를 모두 가져온다.

print(df.query('science>80 & math>20'))
#비교, 산술 등의 operator를 적용해서 다양한 조건을 동시에 만족하는 데이터를 추출할 수도 있다.

df.query('nclass != 2')

k = df.query('english>80 & math>50')
print(k)
print(type(k))
#쿼리로 추출해도 데이터 타입은 그대로 유지된다. -> 그래서 chain method 사용이 가능함.

k.query('english == 97')
#chain method는 이런 식으로 다양한 메소드를 엮어서 사용하는 방법이라고 이해하면 된다.

df.query('english > 90 and math >59')

df.query('english > 95 or math >50')
#and, or를 문자 그대로 사용하는 것도 가능하다.

df.query('nclass ==2 & english > 80 & math > 50')

"""## 특정 열(feature)를 골라서 편집하고 싶은 경우엔 bracket을 활용한다.
- ['feature'], [['feature1','feature2']]
"""

#열을 통째로 추출하고 싶을 땐 배열로 인덱싱하여 전달해주면 된다.
df[['id','math','english']]

df_sp=df[['id','english','math']]

df_sp['english']

p=df[['id']]
print(type(p))
#이차원 배열로 전달한 경우, type은 dataframe이다. 일차원으로 전달하면 series가 반환된다.

"""- 특정 feature를 제거하고 싶은 경우 -> drop 사용"""

df_sp.drop(columns='math')

print(df_sp) #원본 데이터 유지
a=df_sp.drop(columns='math',inplace = False) #inplace = True로 설정하면 원본 데이터를 수정한다.
print(a)

df_sp
#math 데이터가 그대로 남아있는 것을 알 수 있다.

"""### 원본 데이터를 변경하고 싶다면?
- 새로운 변수를 선언해서 변경된 데이터를 지정할 수 있도록 해준다.
- inplace=True로 설정한다.
"""

df_sp.drop(columns='math',inplace=True)

df_sp

a

"""### Method chaining을 적극적으로 활용해볼 수 있다."""

#method chaining
df.query('nclass==1 & math>15 ')[['id','nclass','english']] #type이 일정하게 유지되므로 chaining을 사용할 수 있게 된다.

df.query('nclass==2 & math >40')[['math']] #앞서 살펴보았듯이 이차원으로 전달하면 프레임 형식으로 도출됨.

df.query('nclass==2 & math >40')['math'].to_frame() #아니면 to_frame 활용하기

df.query('nclass==4 & math >30')[['id','nclass','math']]

df[['id','nclass','math']].query('nclass==4 & math >30')

"""## 정렬
- 내림차순, 오름차순
- sort_values()
"""

df.sort_values('math') #괄호 안에 넣은 feature를 기준으로 정렬

df.sort_values('english',ascending=False)[['math','id']]
#정렬 뒤 출력(무엇을 출력할 지도 정할 수 있음)
#영어를 기준으로 정렬한 뒤 수학과 id 정보만을 출력

df.sort_values('math', ascending=False)[['math','id','science']].query('math>20')

"""### 만약 두 개 이상의 조건으로 정렬하고 싶다면?"""

df.sort_values(['math','nclass','science'])
#데이터 추출과 마찬가지로 list 형태로 전달해주면 된다.
#먼저 쓰인 feature을 우선으로 하여 정렬을 진행한다.

df.sort_values(['math','nclass'], ascending=[True,False])
#math를 기준으로 오름차순, nclass를 기준으로 내림차순 정렬한 결과가 표시된다.

"""# 파생변수
 데이터 내부에 포함된 값들을 이용해서 새로운 데이터를 만드는 것을 의미한다.


- 필요성
 1. 데이터 분석에 필요한 경우
    - Ex) 새로운 특징을 기준점으로 분석을 진행해야 하는 경우
 2. 모델링을 통해 feature engineering을 진행하는 경우

- 전체 데이터의 특성을 반영할 수 있도록, 의미와 특징이 손실되지 않도록 논리적 타당성을 갖추는 것이 필요하다.

"""

df['3_mean'] = (df['math']+df['english']+df['science'])/3
#분석에 사용할 수 있도록 기존의 특성을 활용하여 새로운 특성을 만드는 작업

df.assign(mean_s = (df['math']+df['english']+df['science'])/3)
#assign문을 활용해서 실제 데이터에 집어넣는 작업을 수행할 수 있다.

df.assign(3_mean=(df['math']+df['english']+df['science'])/3)
# (주의) 숫자로 시작하는 컬럼명을 쓸 때엔 assign을 쓸 수 없음.

df

df['3_mean'].mean()

df.assign(mean_t = (df['math'] + df['english'] + df['science'])/ 3, inplace=False, no=8)
#계속 추가할 수 있음

import numpy as np

df.assign(test = np.where(df['3_mean']>67.3, '평균이상','평균이하'))
#이런 식으로 numpy와 연계하여 삼항연산자 비슷한 효과를 낼 수도 있다.
#조건을 만족하면 평균이상을, 그렇지 않으면 평균이하를 그 데이터 값으로 갖는 test라는 column을 새롭게 생성한다.

np.where(df['3_mean']>67.3)
#np.where로 쓰면 조건을 만족하는 데이터 행의 인덱스가 배열 형태로 전달된다.

"""### lambda

- df['math'] + df['english'] + df['science']
"""

lambda x : (df['math'] + df['english'] + df['science']) /3

x
#독자적으로 사용해서 변수를 만들 수는 없다.

df.assign(test1 = lambda x : (x['math']+x['english'])/2)
#이런 식으로 assign 문과 연결해서 특정 변수에 x라는 파생 변수를 연결하는 방식으로 사용할 수 있다.

df

"""### groupby
- 그룹으로 묶는 방법이다.
- agg와 함께 쓰여 다양한 데이터 가공을 가능하게 한다.
"""

df
df.groupby('nclass')

df
#데이터 자체가 nclass값에 따라 그룹화되어 정렬된 것을 확인할 수 있다.

df.groupby('nclass').agg(ncl_math = ('math','max'))
#group(그룹화할 대상).agg(새로운 컬럼 이름 = (대상, 방법))

df.groupby('nclass').agg(ncl_math = ('math','mean'))
#class에 따라 묶고, math의 평균값을 새롭게 반환.

df.groupby('nclass').agg(ncl_math = ('math','mean'),
                        ncl_eng = ('english','sum'))#여러 개를 만들 수도 있다.

df_gp=df.groupby('nclass').agg(ncl_math = ('math','std'),
                        ncl_eng = ('english','sum'),
                        ncl_math_mean = ('math','mean'))

df

df_gp=df.groupby('nclass').agg(ncl_math = ('math','std'),
                        ncl_eng = ('english','sum'),
                        ncl_math_mean = ('math','mean'))

df_gp=df.groupby('nclass').agg(ncl_math = ('math','std'),
                        ncl_eng = ('english','max'),
                        ncl_math_mean = ('math','std'))

df_gp